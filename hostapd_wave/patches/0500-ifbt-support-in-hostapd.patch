From c7743d1997d4b264dbb4c0b739f5bbad1cbbcb80 Mon Sep 17 00:00:00 2001
From: Sachin Singla <sachin.singla@iopsys.eu>
Date: Mon, 12 Aug 2019 14:06:20 +0200
Subject: [PATCH 2/2] ifbt support in hostapd

---
 hostapd/config_file.c  |  6 +++--
 hostapd/ctrl_iface.c   | 72 ++++++++++++++++++++++++++++++++++++++++++++++++++
 src/ap/ap_config.h     |  1 +
 src/ap/wpa_auth.c      |  2 +-
 src/ap/wpa_auth.h      |  1 +
 src/ap/wpa_auth_ft.c   | 66 +++++++++++++++++++++++++++++++++++++++++++--
 src/ap/wpa_auth_glue.c | 11 ++++++++
 7 files changed, 154 insertions(+), 5 deletions(-)

diff --git a/hostapd/config_file.c b/hostapd/config_file.c
index 57eb6d4..a710c69 100644
--- a/hostapd/config_file.c
+++ b/hostapd/config_file.c
@@ -979,7 +979,7 @@ static int hostapd_config_tx_queue(struct hostapd_config *conf,
 
 
 #ifdef CONFIG_IEEE80211R
-static int add_r0kh(struct hostapd_bss_config *bss, char *value)
+int add_r0kh(struct hostapd_bss_config *bss, char *value)
 {
 	struct ft_remote_r0kh *r0kh;
 	char *pos, *next;
@@ -1025,7 +1025,7 @@ static int add_r0kh(struct hostapd_bss_config *bss, char *value)
 }
 
 
-static int add_r1kh(struct hostapd_bss_config *bss, char *value)
+int add_r1kh(struct hostapd_bss_config *bss, char *value)
 {
 	struct ft_remote_r1kh *r1kh;
 	char *pos, *next;
@@ -2764,6 +2764,8 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 		bss->pmk_r1_push = atoi(pos);
 	} else if (os_strcmp(buf, "ft_over_ds") == 0) {
 		bss->ft_over_ds = atoi(pos);
+	} else if (os_strcmp(buf, "ft_psk_generate_local") == 0) {
+		bss->ft_psk_generate_local = atoi(pos);
 #endif /* CONFIG_IEEE80211R */
 #ifndef CONFIG_NO_CTRL_IFACE
 	} else if (os_strcmp(buf, "ctrl_interface") == 0) {
diff --git a/hostapd/ctrl_iface.c b/hostapd/ctrl_iface.c
index b9365cd..56c1641 100644
--- a/hostapd/ctrl_iface.c
+++ b/hostapd/ctrl_iface.c
@@ -6646,6 +6646,69 @@ static int hostapd_ctrl_iface_get_last_assoc_req (struct hostapd_data *hapd, con
 	return len;
 }
 
+static int hostapd_ctrl_iface_ft_rrb (struct hostapd_data *hapd, char *cmd)
+{
+	size_t len;
+	u8 *buf;
+	struct l2_ethhdr *ethhdr;
+
+	wpa_printf(MSG_DEBUG, "FT_RRB %s", cmd);
+
+	len = os_strlen(cmd);
+	if (len & 1)
+		return -1;
+	len /= 2;
+
+	buf = os_malloc(len);
+	if (buf == NULL)
+		return -1;
+
+	if (hexstr2bin(cmd, buf, len) < 0) {
+		os_free(buf);
+		return -1;
+	}
+	ethhdr = (struct l2_ethhdr *) buf;
+
+	if (len < sizeof(*ethhdr))
+		return 0;
+
+	wpa_printf(MSG_DEBUG, "FT: RRB received packet " MACSTR " -> "
+		   MACSTR, MAC2STR(ethhdr->h_source), MAC2STR(ethhdr->h_dest));
+	if (!is_multicast_ether_addr(ethhdr->h_dest) &&
+	    os_memcmp(hapd->own_addr, ethhdr->h_dest, ETH_ALEN) != 0)
+		return 0;
+	wpa_ft_rrb_rx(hapd->wpa_auth, ethhdr->h_source, buf + sizeof(*ethhdr),
+		      len - sizeof(*ethhdr));
+	os_free(buf);
+	return 0;
+}
+
+extern int add_r0kh(struct hostapd_bss_config *bss, char *value);
+extern void update_wpa_auth_r0kh(void *hapd_wpa_auth, void *r0kh_list);
+int hostapd_ctrl_iface_r0kh (struct hostapd_data *hapd, char *cmd)
+{
+	wpa_printf(MSG_DEBUG, "r0kh %s", cmd);
+	if (add_r0kh(hapd->conf, cmd) < 0) {
+		wpa_printf(MSG_DEBUG, "Invalid r0kh '%s'", cmd);
+		return 1;
+	}
+	update_wpa_auth_r0kh((void *)hapd->wpa_auth, (void *)hapd->conf->r0kh_list);
+	return 0;
+}
+
+extern int add_r1kh(struct hostapd_bss_config *bss, char *value);
+extern void update_wpa_auth_r1kh(void *hapd_wpa_auth, void *r1kh_list);
+int hostapd_ctrl_iface_r1kh (struct hostapd_data *hapd, char *cmd)
+{
+	wpa_printf(MSG_DEBUG, "r1kh %s", cmd);
+	if (add_r1kh(hapd->conf, cmd) < 0) {
+		wpa_printf(MSG_DEBUG, "Invalid r1kh '%s'", cmd);
+		return 1;
+	}
+	update_wpa_auth_r1kh((void *)hapd->wpa_auth, (void *)hapd->conf->r1kh_list);
+	return 0;
+}
+
 static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 					      char *buf, char *reply,
 					      int reply_size,
@@ -7048,6 +7111,15 @@ static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 			reply_len = -1;
 	} else if (os_strncmp(buf, "GET_LAST_ASSOC_REQ ", sizeof("GET_LAST_ASSOC_REQ ") - 1) == 0) {
 		reply_len = hostapd_ctrl_iface_get_last_assoc_req(hapd, buf + sizeof("GET_LAST_ASSOC_REQ ") - 1, reply, reply_size);
+	} else if (os_strncmp(buf, "FT_RRB ", sizeof("FT_RRB ")-1) == 0) {
+		if (hostapd_ctrl_iface_ft_rrb(hapd, buf + sizeof("FT_RRB ")-1))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "r0kh ", sizeof("r0kh ")-1) == 0) {
+		if (hostapd_ctrl_iface_r0kh(hapd, buf + sizeof("r0kh ")-1))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "r1kh ", sizeof("r1kh ")-1) == 0) {
+		if (hostapd_ctrl_iface_r1kh(hapd, buf + sizeof("r1kh ")-1))
+			reply_len = -1;
 	} else {
 		os_memcpy(reply, "UNKNOWN COMMAND\n", 16);
 		reply_len = 16;
diff --git a/src/ap/ap_config.h b/src/ap/ap_config.h
index 3af7b03..e602d51 100644
--- a/src/ap/ap_config.h
+++ b/src/ap/ap_config.h
@@ -352,6 +352,7 @@ struct hostapd_bss_config {
 	struct ft_remote_r1kh *r1kh_list;
 	int pmk_r1_push;
 	int ft_over_ds;
+	int ft_psk_generate_local;
 #endif /* CONFIG_IEEE80211R */
 
 	char *ctrl_interface; /* directory for UNIX domain sockets */
diff --git a/src/ap/wpa_auth.c b/src/ap/wpa_auth.c
index b41661b..d67112e 100644
--- a/src/ap/wpa_auth.c
+++ b/src/ap/wpa_auth.c
@@ -101,7 +101,7 @@ static inline int wpa_auth_get_eapol(struct wpa_authenticator *wpa_auth,
 }
 
 
-static inline const u8 * wpa_auth_get_psk(struct wpa_authenticator *wpa_auth,
+const u8 * wpa_auth_get_psk(struct wpa_authenticator *wpa_auth,
 					  const u8 *addr,
 					  const u8 *p2p_dev_addr,
 					  const u8 *prev_psk)
diff --git a/src/ap/wpa_auth.h b/src/ap/wpa_auth.h
index 657b53b..6bf5798 100644
--- a/src/ap/wpa_auth.h
+++ b/src/ap/wpa_auth.h
@@ -171,6 +171,7 @@ struct wpa_auth_config {
 	struct ft_remote_r1kh *r1kh_list;
 	int pmk_r1_push;
 	int ft_over_ds;
+	int ft_psk_generate_local;
 #endif /* CONFIG_IEEE80211R */
 	int disable_gtk;
 	int ap_mlme;
diff --git a/src/ap/wpa_auth_ft.c b/src/ap/wpa_auth_ft.c
index e63b99a..5f9d015 100644
--- a/src/ap/wpa_auth_ft.c
+++ b/src/ap/wpa_auth_ft.c
@@ -23,6 +23,21 @@
 
 
 #ifdef CONFIG_IEEE80211R
+void update_wpa_auth_r0kh(void *hapd_wpa_auth, void *hapd_r0kh_list) {
+	struct wpa_authenticator *wpa_auth = hapd_wpa_auth;
+	struct ft_remote_r0kh *r0kh_list = hapd_r0kh_list;
+	struct wpa_auth_config *wconf;
+	wconf = &(wpa_auth->conf);
+	wconf->r0kh_list = r0kh_list;
+}
+
+void  update_wpa_auth_r1kh(void *hapd_wpa_auth, void *hapd_r1kh_list) {
+	struct wpa_authenticator *wpa_auth = hapd_wpa_auth;
+	struct ft_remote_r1kh *r1kh_list = hapd_r1kh_list;
+	struct wpa_auth_config *wconf;
+	wconf = &(wpa_auth->conf);
+	wconf->r1kh_list = r1kh_list;
+}
 
 static int wpa_ft_send_rrb_auth_resp(struct wpa_state_machine *sm,
 				     const u8 *current_ap, const u8 *sta_addr,
@@ -802,7 +817,50 @@ void wpa_ft_install_ptk(struct wpa_state_machine *sm)
 	sm->pairwise_set = TRUE;
 	sm->tk_already_set = TRUE;
 }
+extern const u8 * wpa_auth_get_psk(struct wpa_authenticator *wpa_auth,
+	const u8 *addr, const u8 *p2p_dev_addr, const u8 *prev_psk);
 
+static int wpa_ft_psk_pmk_r1(struct wpa_state_machine *sm,
+	const u8 *req_pmk_r1_name, u8 *out_pmk_r1, int *out_pairwise)
+{
+	u8 pmk_r0[PMK_LEN], pmk_r0_name[WPA_PMK_NAME_LEN];
+	u8 pmk_r1[PMK_LEN], pmk_r1_name[WPA_PMK_NAME_LEN];
+	u8 *mdid = sm->wpa_auth->conf.mobility_domain;
+	u8 *r0kh = sm->r0kh_id;
+	size_t r0kh_len = sm->r0kh_id_len;
+	const u8 *r1kh = sm->wpa_auth->conf.r1_key_holder;
+	u8 *ssid = sm->wpa_auth->conf.ssid;
+	size_t ssid_len = sm->wpa_auth->conf.ssid_len;
+	int pairwise;
+	const u8 *pmk = NULL;
+
+	pairwise = sm->wpa_auth->conf.rsn_pairwise;
+	for (;;) {
+		pmk = wpa_auth_get_psk(sm->wpa_auth, sm->addr, sm->p2p_dev_addr,
+				     pmk);
+		if (pmk == NULL)
+			break;
+		wpa_derive_pmk_r0(pmk, PMK_LEN, ssid, ssid_len, mdid, r0kh,
+					      r0kh_len, sm->addr,
+					      pmk_r0, pmk_r0_name);
+		wpa_derive_pmk_r1(pmk_r0, pmk_r0_name, r1kh, sm->addr,
+					      pmk_r1, pmk_r1_name);
+
+		if (memcmp(pmk_r1_name, req_pmk_r1_name, WPA_PMK_NAME_LEN) != 0) {
+			wpa_printf(MSG_DEBUG, "FT: did not find PSK to generate PMK_R1 locally");
+			continue;
+		}
+
+		/* we found a PSK that matches the request pmk_r1_name */
+		wpa_printf(MSG_DEBUG, "FT: found PSK to generate PMK_R1 locally");
+		memcpy(out_pmk_r1, pmk_r1, PMK_LEN);
+		if (out_pairwise)
+			*out_pairwise = pairwise;
+		return 0;
+	}
+	wpa_printf(MSG_DEBUG, "FT: did not find PSK to generate PMK_R1 locally");
+	return -1;
+}
 
 static int wpa_ft_process_auth_req(struct wpa_state_machine *sm,
 				   const u8 *ies, size_t ies_len,
@@ -872,8 +930,12 @@ static int wpa_ft_process_auth_req(struct wpa_state_machine *sm,
 			       pmk_r1_name);
 	wpa_hexdump(MSG_DEBUG, "FT: Derived requested PMKR1Name",
 		    pmk_r1_name, WPA_PMK_NAME_LEN);
-
-	if (wpa_ft_fetch_pmk_r1(sm->wpa_auth, sm->addr, pmk_r1_name, pmk_r1,
+	if (conf->ft_psk_generate_local &&
+	    wpa_key_mgmt_ft(sm->wpa_auth->conf.wpa_key_mgmt)) {
+		if (wpa_ft_psk_pmk_r1(sm, pmk_r1_name, pmk_r1, &pairwise) < 0)
+			return WLAN_STATUS_INVALID_PMKID;
+		wpa_printf(MSG_DEBUG, "FT: Generated PMK-R1 for FT-PSK locally");
+	} else if (wpa_ft_fetch_pmk_r1(sm->wpa_auth, sm->addr, pmk_r1_name, pmk_r1,
 		    &pairwise) < 0) {
 		if (wpa_ft_pull_pmk_r1(sm, ies, ies_len, parse.rsn_pmkid) < 0) {
 			wpa_printf(MSG_DEBUG, "FT: Did not have matching "
diff --git a/src/ap/wpa_auth_glue.c b/src/ap/wpa_auth_glue.c
index 7186b2c..36f5dd3 100644
--- a/src/ap/wpa_auth_glue.c
+++ b/src/ap/wpa_auth_glue.c
@@ -74,6 +74,7 @@ static void hostapd_wpa_auth_conf(struct hostapd_bss_config *conf,
 	wconf->r1kh_list = conf->r1kh_list;
 	wconf->pmk_r1_push = conf->pmk_r1_push;
 	wconf->ft_over_ds = conf->ft_over_ds;
+	wconf->ft_psk_generate_local = conf->ft_psk_generate_local;
 #endif /* CONFIG_IEEE80211R */
 #ifdef CONFIG_HS20
 	wconf->disable_gtk = conf->disable_dgaf;
@@ -497,6 +498,16 @@ static int hostapd_wpa_auth_send_ether(void *ctx, const u8 *dst, u16 proto,
 	os_memcpy(buf->h_source, hapd->own_addr, ETH_ALEN);
 	buf->h_proto = host_to_be16(proto);
 	os_memcpy(buf + 1, data, data_len);
+	{
+		size_t hex_len = 2 * (sizeof(*buf) + data_len) + 1;
+		char *hex = os_malloc(hex_len);
+
+		if (hex == NULL)
+			return -1;
+		wpa_snprintf_hex(hex, hex_len, (u8 *)buf, sizeof(*buf) + data_len);
+		wpa_msg(hapd->msg_ctx, MSG_INFO, "FT_RRB " "%s", hex);
+		os_free(hex);
+	}
 	ret = l2_packet_send(hapd->l2, dst, proto, (u8 *) buf,
 			     sizeof(*buf) + data_len);
 	os_free(buf);
-- 
2.7.4

